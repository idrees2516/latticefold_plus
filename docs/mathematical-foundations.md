# Mathematical Foundations of LatticeFold+

This document provides a comprehensive mathematical specification of the LatticeFold+ protocol, including formal definitions, security proofs, and implementation details.

## Table of Contents

1. [Notation and Preliminaries](#notation-and-preliminaries)
2. [Cyclotomic Rings](#cyclotomic-rings)
3. [Commitment Schemes](#commitment-schemes)
4. [Range Proofs](#range-proofs)
5. [Folding Protocols](#folding-protocols)
6. [Security Analysis](#security-analysis)
7. [Implementation Considerations](#implementation-considerations)

## Notation and Preliminaries

### Basic Notation

- **R**: The cyclotomic ring R = Z[X]/(X^d + 1) where d is a power of 2
- **Rq**: The quotient ring Rq = R/qR for prime modulus q
- **κ**: Security parameter (typically 128 or 256 bits)
- **d**: Ring dimension (power of 2, typically 512-4096)
- **q**: Prime modulus satisfying q ≡ 1 (mod 2d) for NTT compatibility
- **||·||∞**: Infinity norm (maximum absolute value of coefficients)
- **⟨·,·⟩**: Inner product over rings
- **⊗**: Tensor product operation

### Probability and Complexity

- **negl(λ)**: Negligible function in security parameter λ
- **poly(λ)**: Polynomial function in security parameter λ
- **Pr[E]**: Probability of event E
- **O(·), Ω(·), Θ(·)**: Standard asymptotic notation

### Lattice Theory

- **Λ**: Lattice generated by basis vectors
- **det(Λ)**: Determinant of lattice Λ
- **λ₁(Λ)**: First minimum (shortest non-zero vector length)
- **γ**: Approximation factor for lattice problems

## Cyclotomic Rings

### Definition 2.1 (Cyclotomic Ring)

The cyclotomic ring R is defined as:
```
R = Z[X]/(X^d + 1)
```
where d is a power of 2. Elements of R are polynomials of degree less than d with integer coefficients.

### Properties

1. **Ring Structure**: R is a commutative ring with unity
2. **Negacyclic Property**: X^d = -1 in R
3. **Canonical Embedding**: R ↪ C^d via evaluation at primitive 2d-th roots of unity
4. **Norm and Trace**: Well-defined via canonical embedding

### Arithmetic Operations

**Addition**: (a + b)(X) = a(X) + b(X)
**Multiplication**: (a · b)(X) = a(X) · b(X) mod (X^d + 1)
**Norm**: ||a||∞ = max_i |a_i| for a = Σ a_i X^i

### Number Theoretic Transform (NTT)

For efficient multiplication, we use NTT when q ≡ 1 (mod 2d):

**Forward NTT**: â[i] = Σ_{j=0}^{d-1} a[j] · ω^{ij} mod q
**Inverse NTT**: a[j] = d^{-1} · Σ_{i=0}^{d-1} â[i] · ω^{-ij} mod q

where ω is a primitive 2d-th root of unity modulo q.

## Commitment Schemes

### Linear Commitment Scheme

#### Definition 3.1 (Linear Commitment)

A linear commitment scheme over Rq consists of:
- **Setup**: Generate A ← Rq^{κ×m} uniformly at random
- **Commit**: com(a) = Aa for a ∈ Rq^m
- **Open**: Verify com(a) = Aa for given opening a

#### Security Properties

**Binding**: For any PPT adversary A, the probability that A outputs (a₁, a₂) with a₁ ≠ a₂ but Aa₁ = Aa₂ is negligible.

**Hiding**: For any a₁, a₂ ∈ Rq^m, the distributions com(a₁) and com(a₂) are computationally indistinguishable.

### Module-SIS Assumption

#### Definition 3.2 (Module-SIS)

The Module Short Integer Solution (MSIS) problem is: given A ← Rq^{κ×m}, find x ∈ Rq^m such that Ax = 0 and 0 < ||x||∞ ≤ β.

The MSIS_{q,κ,m,β} assumption states that no PPT algorithm can solve MSIS with non-negligible probability.

### Double Commitment Scheme

#### Definition 3.3 (Split Function)

The split function split: Rq^{κ×m} → (-d', d')^n is defined as:
1. Compute M' = G_{d',ℓ}^{-1}(com(M)) where G is the gadget matrix
2. Flatten M'' = flat(M') ∈ Rq^{κmℓ}
3. Extract coefficients τ'_M = flat(cf(M'')) ∈ (-d', d')^{κmℓd}
4. Zero-pad to τ_M ∈ (-d', d')^n

#### Definition 3.4 (Power Function)

The power function pow: (-d', d')^n → Rq^{κ×m} is the partial inverse of split.

#### Definition 3.5 (Double Commitment)

The double commitment is defined as:
```
dcom(M) = com(split(com(M))) ∈ Rq^κ
```

### Security Analysis

**Theorem 3.1 (Double Commitment Binding)**
If the linear commitment scheme is (β, S)-binding, then the double commitment scheme is (β', S')-binding where β' and S' depend on the gadget parameters.

*Proof Sketch*: The binding property reduces to three cases:
1. Collision in com(M): Contradicts linear commitment binding
2. Collision in τ: Contradicts injectivity of split
3. Consistency violation: Contradicts gadget matrix properties

## Range Proofs

### Monomial Sets and Exponential Mappings

#### Definition 4.1 (Extended Monomial Set)

The extended monomial set is M' = {0, 1, X, X², X³, ...} ⊆ Zq[X].

#### Definition 4.2 (Finite Monomial Set)

The finite monomial set is M = {0, 1, X, X², ..., X^{d-1}} ⊆ M' ⊆ Rq.

#### Lemma 4.1 (Monomial Characterization)

For a ∈ Rq, we have a ∈ M' if and only if a(X²) = a(X)².

*Proof*: This follows from the fact that monomials satisfy the functional equation f(X²) = f(X)² when f(X) = X^k.

#### Definition 4.3 (Exponential Mappings)

- **Sign function**: sgn(a) ∈ {-1, 0, 1} for a ∈ (-d, d)
- **Exponential mapping**: exp(a) = sgn(a)X^a
- **Set-valued mapping**: EXP(a) = {exp(a)} for a ≠ 0, EXP(0) = {0, 1, X^{d/2}}

### Range Polynomial Construction

#### Definition 4.4 (Range Polynomial)

For d' = d/2, the range polynomial is:
```
ψ = Σ_{i∈[1,d')} i·(X^{-i} + X^i)
```

where X^{-i} = -X^{d-i} in Rq.

#### Theorem 4.1 (Range Proof Correctness)

For f ∈ Rq with ||f||∞ < d'/2, there exists a decomposition Df such that:
1. Mf ∈ EXP(Df) (monomial matrix property)
2. ct(b·ψ) encodes the range information for appropriate b

### Algebraic Range Proof Protocol

#### Protocol 4.1 (Πrgchk)

**Input**: Witness f ∈ Rq^n with claimed range ||f_i||∞ < d'/2

**Prover**:
1. Compute decomposition Df = G_{d',k}^{-1}(cf(f))
2. Construct monomial matrix Mf ∈ EXP(Df)
3. Generate double commitment CMf = dcom(Mf)
4. Prove consistency between f and Df
5. Run monomial set checking protocol

**Verifier**:
1. Verify double commitment CMf
2. Check consistency proof
3. Verify monomial set checking proof

**Theorem 4.2 (Range Proof Security)**
Protocol Πrgchk is complete, sound, and zero-knowledge under the MSIS assumption.

## Folding Protocols

### Multi-Instance Folding

#### Definition 5.1 (Linear Relation)

A linear relation R_{lin,B} consists of tuples (A, b, u) where:
- A ∈ Rq^{κ×n}: Constraint matrix
- b ∈ Rq^κ: Target vector  
- u ∈ Rq^n: Witness vector
- ||u||∞ ≤ B: Norm bound

such that Au = b.

#### Protocol 5.1 (Multi-Instance Folding Πmlin,L,B)

**Input**: L instances (A_i, b_i, u_i) ∈ R_{lin,B}

**Prover**:
1. Commit to all witnesses: cm_i = com(u_i)
2. Receive folding challenges s_i ← S̄
3. Compute folded witness: u = Σ_i s_i u_i
4. Prove ||u||∞ ≤ B² using decomposition protocol

**Verifier**:
1. Verify witness commitments
2. Check folded relation: (Σ_i s_i A_i)(u) = Σ_i s_i b_i
3. Verify norm bound proof

#### Theorem 5.1 (Folding Soundness)

If any individual instance is not in R_{lin,B}, then the folded instance is not in R_{lin,B²} except with probability 1/|S̄|.

### Witness Decomposition Protocol

#### Protocol 5.2 (Πdecomp,B)

**Purpose**: Reduce R_{lin,B²} to R_{lin,B}^{(2)}

**Input**: Instance (A, b, u) with ||u||∞ ≤ B²

**Prover**:
1. Decompose witness: u = F × [1, B]^T where ||F||∞ ≤ B
2. Commit to decomposed witness: C = com(F)
3. Prove consistency: A(F × [1, B]^T) = b

**Verifier**:
1. Verify decomposed commitment
2. Check consistency relation
3. Accept if all checks pass

## Security Analysis

### Computational Assumptions

#### Assumption 6.1 (Ring-LWE)

The Ring Learning With Errors (Ring-LWE) problem is: distinguish between (a, as + e) and (a, u) where:
- a ← Rq uniform
- s ← χ (secret distribution)
- e ← χ (error distribution)  
- u ← Rq uniform

#### Assumption 6.2 (Module-SIS)

As defined in Definition 3.2, with parameters chosen such that:
- q ≥ 2^{128} for 128-bit security
- β ≤ poly(κ) for polynomial norm bounds
- κ ≥ log q for sufficient entropy

### Security Reductions

#### Theorem 6.1 (Commitment Binding)

The linear commitment scheme is binding under the MSIS_{q,κ,m,β} assumption with β = 2B||S||_{op} where B is the norm bound and S is the challenge set.

*Proof*: Any binding violation (z₁, z₂) with Az₁s₁^{-1} = Az₂s₂^{-1} but z₁s₁^{-1} ≠ z₂s₂^{-1} gives MSIS solution x = s₂z₁ - s₁z₂ with ||x||∞ ≤ 2B||S||_{op}.

#### Theorem 6.2 (Range Proof Soundness)

The range proof protocol has soundness error ε ≤ (kℓ/|C|)^r where:
- k: number of sumcheck variables
- ℓ: polynomial degree
- |C|: challenge set size
- r: repetition parameter

#### Theorem 6.3 (Folding Soundness)

The multi-instance folding protocol has soundness error ε ≤ L/|S̄| where L is the number of instances and |S̄| is the challenge set size.

### Concrete Security Parameters

For 128-bit security, we recommend:
- Ring dimension: d = 2048
- Modulus: q ≈ 2^{60} (NTT-friendly prime)
- Security parameter: κ = 256
- Challenge set size: |S̄| ≥ 2^{40}
- Repetition parameter: r ≥ 3

## Implementation Considerations

### Numerical Precision

All arithmetic operations must handle:
- **Overflow detection**: Check for coefficient overflow during operations
- **Modular reduction**: Maintain coefficients in balanced representation [-q/2, q/2]
- **NTT precision**: Use sufficient precision for twiddle factor computation

### Constant-Time Implementation

For side-channel resistance:
- **Conditional operations**: Use constant-time conditional moves
- **Memory access**: Ensure access patterns don't leak secret information
- **Timing consistency**: Operations should take constant time regardless of input

### Performance Optimizations

- **SIMD vectorization**: Use AVX2/AVX-512 for parallel coefficient operations
- **GPU acceleration**: Implement CUDA kernels for large polynomial operations
- **Memory management**: Use memory pools to reduce allocation overhead
- **Batch processing**: Process multiple instances together when possible

### Error Handling

Implement comprehensive error checking for:
- **Parameter validation**: Ensure all parameters are within valid ranges
- **Dimension consistency**: Check that all operations have compatible dimensions
- **Norm bounds**: Verify that all norm bounds are satisfied
- **Cryptographic validation**: Check that all cryptographic operations succeed

## References

1. **[BDLOP18]** Baum, C., Damgård, I., Lyubashevsky, V., Oechsner, S., Peikert, C.: More efficient commitments from structured lattice assumptions. In: SCN 2018.

2. **[LNS21]** Lyubashevsky, V., Nguyen, N.K., Seiler, G.: Shorter lattice-based zero-knowledge proofs via one-time commitments. In: PKC 2021.

3. **[BLNS23]** Baum, C., Lyubashevsky, V., Nguyen, N.K., Seiler, G.: Lattice-based zero-knowledge proofs and applications: Shorter, simpler, and more general. In: CRYPTO 2023.

4. **[LatticeFold]** Original LatticeFold paper reference.

5. **[LatticeFold+]** This work: LatticeFold+ with algebraic range proofs and improved efficiency.